{
    "name": "event_scheduler",
    "task_description": "\nProblem Description:\n\nInput:\n\nYou have a list of events.\nEach event is represented as a tuple (start, end, score).\nstart: The starting hour of the event (an integer between 0 and 10).\nend: The ending hour of the event (an integer between start and 10).\nscore: The importance score of the event (a positive integer).\nConstraints:\n\nThe events can only be scheduled between the hours of 0:00 and 10:00.\nNo two events can overlap. An event with an end time of X cannot overlap with another event with a start time of X.\nEach event can be scheduled only once.\nObjective:\n\nYour goal is to schedule the events in such a way that the total importance score is maximized.\nThe algorithm should return the maximum total importance score that can be achieved with the given set of events.\n\nExample:\n\nSuppose you have the following list of events:\n\nEvent 1: (1, 3, 5)\nEvent 2: (1, 2, 3)\nEvent 3: (2, 3, 4)\n\nBest schedule would be to pick Event 2 and Event 3, which would give a total importance score of 7.\n\nThe algorithm should determine the best way to schedule these events between 0:00 and 10:00 to achieve the highest total importance score, without any overlapping of events.\n\nOutput: The algorithm should return a single integer, which is the highest total importance score achievable under the given constraints.\n",
    "function_signature": "\ntest_events = [(1, 2, 10), (2,3,5), (1,3,14)]\n\ndef schedule_events(events):\n    '''\n    events is a list of tuples of the form (start_time, end_time, score)\n    '''\n    score = 0\n    # write your code here\n\n    return score\n\nprint(schedule_events(test_events))\n",
    "unit_test": "\n# Test Case 1: Single event\nevents = [(0, 2, 10)]\nassert schedule_events(events) == 10, \"Test Case 1 Failed\"\n\n# Test Case 2: Two non-overlapping events\nevents = [(0, 2, 10), (2, 4, 15)]\nassert schedule_events(events) == 25, \"Test Case 2 Failed\"\n\n# Test Case 3: Two overlapping events, one with higher score\nevents = [(0, 3, 10), (2, 5, 20)]\nassert schedule_events(events) == 20, \"Test Case 3 Failed\"\n\n# Test Case 4: Multiple events, some overlapping\nevents = [(0, 3, 10), (2, 5, 15), (5, 7, 20)]\nassert schedule_events(events) == 35, \"Test Case 4 Failed\"\n\n# Test Case 5: Events with the same time\nevents = [(1, 4, 10), (1, 4, 15)]\nassert schedule_events(events) == 15, \"Test Case 5 Failed\"\n\n# Test Case 6: Events spread throughout the day\nevents = [(0, 2, 10), (3, 5, 15), (6, 8, 20), (9, 10, 25)]\nassert schedule_events(events) == 70, \"Test Case 6 Failed\"\n\n# Test Case 7: Non-overlapping events with equal score\nevents = [(0, 2, 10), (2, 4, 10), (4, 6, 10)]\nassert schedule_events(events) == 30, \"Test Case 7 Failed\"\n\n# Test Case 8: Overlapping events with varying scores\nevents = [(0, 4, 20), (3, 5, 30), (5, 7, 25)]\nassert schedule_events(events) == 55, \"Test Case 8 Failed\"\n\n# Test Case 9: All events overlapping\nevents = [(1, 3, 10), (2, 4, 15), (2, 5, 20)]\nassert schedule_events(events) == 20, \"Test Case 9 Failed\"\n\n\nprint(\"All test cases passed!\")\n",
    "solution": "\ndef binary_search(events, index):\n    lo, hi = 0, index - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if events[mid][1] <= events[index][0]:\n            if events[mid + 1][1] <= events[index][0]:\n                lo = mid + 1\n            else:\n                return mid\n        else:\n            hi = mid - 1\n    return -1\n\ndef schedule_events(events):\n    # Sort the events based on their end time\n    events.sort(key=lambda x: x[1])\n\n    n = len(events)\n    dp = [0] * n\n    dp[0] = events[0][2]\n\n    for i in range(1, n):\n        incl_prof = events[i][2]\n        l = binary_search(events, i)\n        if l != -1:\n            incl_prof += dp[l]\n\n        dp[i] = max(incl_prof, dp[i - 1])\n\n    return dp[n-1]\n",
    "type": "logic"
}